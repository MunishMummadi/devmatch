package routes

import (
	"log"
	"net/http"

	"server/api/handlers"               // <-- Adjust import path
	"server/api/middleware"             // <-- Adjust import path
	"server/internal/services/database" // <-- Adjust import path

	"github.com/clerkinc/clerk-sdk-go/clerk"
	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	// If using Swagger/Swaggo for docs
	// ginSwagger "github.com/swaggo/gin-swagger"
	// swaggerFiles "github.com/swaggo/files"
	// _ "your-project-name/docs" // docs is generated by Swag CLI
)

func SetupRouter(dbPool *pgxpool.Pool, clerkClient clerk.Client) *gin.Engine {
	// Set Gin mode (debug, release, test)
	ginMode := gin.DebugMode // Default or get from config
	if mode := gin.Mode(); mode != "" {
		ginMode = mode
	}
	gin.SetMode(ginMode)

	router := gin.Default() // Includes logger and recovery middleware

	// --- Middleware ---
	// CORS (Allow requests from your frontend) - Configure properly for production
	router.Use(func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*") // Allow any origin (adjust for prod)
		c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}
		c.Next()
	})

	// Create services and handlers
	dbService := database.NewDBService(dbPool)
	authHandler := handlers.NewAuthHandler(dbService)
	userHandler := handlers.NewUserHandler(dbService)
	// chatHandler := handlers.NewChatHandler(dbService)       // TODO
	// dashboardHandler := handlers.NewDashboardHandler(dbService) // TODO
	// githubHandler := handlers.NewGitHubHandler(geminiService)  // TODO

	// Clerk Authentication Middleware Instance
	authMiddleware := middleware.ClerkMiddleware(clerkClient)

	// --- Routes ---
	// Public Routes (e.g., health check, maybe docs)
	router.GET("/health", func(c *gin.Context) { c.JSON(200, gin.H{"status": "UP"}) })

	// Optional: Swagger Docs endpoint (if using Swaggo)
	// router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// Authentication Routes
	authGroup := router.Group("/auth")
	{
		// These often involve redirects handled by Clerk's frontend SDKs / Hosted Pages
		// Placeholder endpoints - Actual implementation depends heavily on Clerk setup
		authGroup.GET("/github/login", func(c *gin.Context) {
			// Typically redirect to Clerk's hosted auth page or use frontend SDK
			c.JSON(http.StatusNotImplemented, gin.H{"message": "Redirect to Clerk/GitHub handled by frontend or Clerk hosted pages"})
		})
		authGroup.GET("/github/callback", func(c *gin.Context) {
			// Clerk handles the callback and sets cookies/tokens
			c.JSON(http.StatusNotImplemented, gin.H{"message": "Callback processed by Clerk; frontend should redirect"})
		})

		// Requires Authentication via Clerk session
		authGroup.GET("/user", authMiddleware, authHandler.GetCurrentUserProfile)
		authGroup.POST("/logout", authMiddleware, func(c *gin.Context) {
			// Backend can't easily invalidate Clerk session cookie (HttpOnly).
			// Needs coordination with frontend Clerk SDK (signOut()).
			c.JSON(http.StatusOK, gin.H{"message": "Logout initiated. Frontend should clear session."})
		})

	}

	// User Profile Routes
	userGroup := router.Group("/users")
	{
		// Get public profile - potentially doesn't require auth depending on your rules
		userGroup.GET("/:id", userHandler.GetUserProfileByID) // :id is DB ID

		// Create or Update OWN profile - Requires Authentication
		userGroup.POST("/profile", authMiddleware, userHandler.CreateOrUpdateCurrentUserProfile)

		// TODO: userGroup.PUT("/:id", authMiddleware, userHandler.EditUserProfile) // Requires auth + check if user edits own profile
		// TODO: userGroup.GET("/random", authMiddleware, userHandler.GetRandomUsers) // Requires auth?
	}

	// Chatting Routes (TODO) - Apply authMiddleware
	chatGroup := router.Group("/chat", authMiddleware)
	{
		chatGroup.GET("/conversations/:userId", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Get conversations"}) })
		chatGroup.GET("/messages/:conversationId", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Get messages"}) })
		chatGroup.POST("/message", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Send message"}) })
		// chatGroup.POST("/speech-to-text", ...) // Optional
	}

	// Swiping / Dashboard Routes (TODO) - Apply authMiddleware
	dashboardGroup := router.Group("/dashboard", authMiddleware)
	{
		dashboardGroup.GET("/cards", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Get swipe cards"}) }) // Likely same as /users/random
		dashboardGroup.POST("/swipe", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Log swipe"}) })
		dashboardGroup.POST("/favorite", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Add/remove favorite"}) })
		dashboardGroup.GET("/favorites", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Get favorites"}) })
	}

	// Optional Dev Tools (TODO) - Potentially apply authMiddleware depending on use case
	githubGroup := router.Group("/github")
	{
		githubGroup.GET("/:username/data", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Scrape GitHub data"}) })
		githubGroup.POST("/summary", func(c *gin.Context) { c.JSON(http.StatusNotImplemented, gin.H{"message": "TODO: Send data to Gemini"}) })
	}

	log.Println("Router setup complete.")
	return router
}
